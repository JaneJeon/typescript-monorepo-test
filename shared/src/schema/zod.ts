import * as z from 'zod'
import { hashids } from '../utils/hashids.js'

// Can't be done with JSON Schema (1)
// "Initial"/"Autogenerated" values need to be set in the model, not the schema,
// because we don't ever want the user to be setting these,
// so the values will always be empty.
export const BaseSchemaZod = z.object({
  createdAt: z
    .string()
    .datetime()
    .describe(
      'An ISO timestamp string indicating when the object was created. Do not set directly.'
    ),
  updatedAt: z
    .string()
    .datetime()
    .describe(
      'An ISO timestamp string indicating when the object was updated. Do not set directly.'
    )
})

// Object representation to be used as the shape of transport in the "API boundary".
// That means anything here must be "representable" as a regular ol' JSON.
export const UserSchemaZod = BaseSchemaZod.extend({
  id: z
    .string()
    .describe('The user ID (that is auto-generated from the backend).'),
  name: z
    .string()
    .min(1)
    .describe('The username that is provided by the user.'),
  role: z
    .enum(['user', 'superuser'])
    .describe(
      'The role for the user. Note that superuser status can only be set by another superuser/admin.'
    ),
  deactivated: z
    .boolean()
    .describe(
      'Deleted users will be marked with the `deactivated` flag. Do not set directly.'
    )
}).strict() // this applies to all schemas that extend off of this schema

// Object representation of the payload that is allowed (coming into the backend) when creating a user
export const CreateUserSchemaZod = UserSchemaZod.pick({ id: true, name: true })

// Object representation of the payload that is allowed (coming into the backend) when updating a user
export const UpdateUserSchemaZod = UserSchemaZod.pick({
  name: true,
  role: true,
  deactivated: true
})

const MetadataBaseSchemaZod = z
  .object({
    author: z.string().describe('The author listed for the page.'),
    description: z.string().describe('The description listed for the page.'),
    lang: z.string().describe('The language listed for the page.'),
    publisher: z.string().describe('The publisher listed for the page.')
  })
  .strip()

const MetadataDateSchemaZod = z.coerce
  .date()
  .transform(
    val => `${val.getUTCFullYear()}-${val.getUTCMonth()}-${val.getUTCDate()}`
  )
  .describe('The date the page was published (in UTC).')
const MetadataLogoSchemaZod = z
  .string()
  .url()
  .describe('The URL of the logo for the page.')

const MetadataSchemaZod = z
  .union([
    MetadataBaseSchemaZod,
    MetadataBaseSchemaZod.strict().extend({ date: MetadataDateSchemaZod }),
    MetadataBaseSchemaZod.strict().extend({ logo: MetadataLogoSchemaZod }),
    MetadataBaseSchemaZod.strict().extend({
      date: MetadataDateSchemaZod,
      logo: MetadataLogoSchemaZod
    })
  ])
  .optional()
  .describe(
    'A set of metadata about the link that was shortened. See the metascraper project for more info.'
  )

// Object representation to be used as the shape of transport in the "API boundary".
// That means anything here must be "representable" as a regular ol' JSON,
// and that the shape of the object represents the *external* shape of the Link, not internal.
export const LinkSchemaZod = BaseSchemaZod.extend({
  id: z.string().describe('The ID of the link. Generated by the backend.'),
  creatorId: UserSchemaZod.shape.id.describe(
    'ID of the user who created the link.'
  ),
  originalLink: z.string().url().describe('The link that was shortened.'),
  shortLink: z
    .string()
    .url()
    .describe('The shortened link with auto-generated URL pathname.'),
  brandLink: z
    .string()
    .url()
    .optional()
    .describe('The shortened link with a user-specified URL pathname.'),
  //   metadata: z
  //     .object({
  //       author: z.string(),
  //       // This either fits the schema, or is set as `undefined`.
  //       // Can't be done with JSON Schema (2)
  //       // TODO: is there a way I can just have the property not set at all?
  //       // perhaps as a 'union' of schema/possibilities?
  //       // if so, maybe could be done in json schema too?
  //       date: z.string().transform(val => {
  //         const str = new Date(val).toDateString()
  //         return str === 'Invalid Date' ? undefined : str
  //       }),
  //       description: z.string(),
  //       lang: z.string(),
  //       logo: z.string().transform(val => {
  //         // TODO: validate val is url
  //         return val // or undefined
  //       }),
  //       publisher: z.string()
  //     })
  //     .strict() // additionalProperties: false
  //     .partial() // All of the fields are optional
  //     .optional() // the metadata object itself is also optional
  //     .describe(
  //       'A set of metadata about the link that was shortened. See the metascraper project for more info.'
  //     )
  metadata: MetadataSchemaZod
}).strict()

export const CreateLinkSchemaZod = LinkSchemaZod.pick({
  originalLink: true
}).extend({
  pathname: z
    .string()
    .min(4)
    .max(25)
    .regex(/^[\w-]+$/) // a-z, A-Z, 0-9, -
    .refine(
      // Can't be done with JSON Schema (3)
      val => {
        // Since custom and auto-generated hash are both mounted under /,
        // we need to check that custom hash CAN'T clash with autogenerated hash.
        try {
          const ids = hashids.decode(val)
          return ids.length ? false : true
        } catch (err) {
          // when the hash contains "invalid" characters, we know for sure it CAN'T clash.
          return true
        }
      },
      {
        message: 'You cannot pick this pathname.'
      }
    )
    .optional()
    .describe(
      'You can set a pathname to customize the shortened link (see: brandLink).'
    )
})

// The check of "don't allow update if the path is already set" belongs to authorization
export const UpdateLinkSchemaZod = CreateLinkSchemaZod.pick({
  pathname: true
}).merge(LinkSchemaZod.pick({ metadata: true }))
