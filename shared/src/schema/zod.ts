import * as z from 'zod'
import { hashids } from '../utils/hashids.js'
import normalizeUrl from 'normalize-url'
import isURL from 'validator/lib/isURL.js' // can't use /es/lib tree-shakeable import...
// See: https://github.com/validatorjs/validator.js/issues/1581
// and https://github.com/validatorjs/validator.js/issues/1759

const NonEmptyString = z.string().trim().min(1)

const UrlSchema = NonEmptyString.transform(val => normalizeUrl(val)).refine(
  val => isURL(val, { protocols: ['http', 'https'], require_protocol: true })
)

const CoercedBoolean = z
  .string()
  .optional()
  .default('false') // for boolean options, the absence should always be negative
  .transform((val, ctx) => {
    if (val === 'true') return true
    if (val === 'false') return false

    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: 'Invalid Boolean value'
    })

    return z.NEVER
  })

// Don't allow extra fields at all
const StrictObject = z.object({}).strict()

// Strip extra fields
const StripObject = z.object({}).strip()

// Can't be done with JSON Schema (1)
// "Initial"/"Autogenerated" values need to be set in the model, not the schema,
// because we don't ever want the user to be setting these,
// so the values will always be empty.
const BaseSchema = StrictObject.extend({
  createdAt: z
    .string()
    .datetime()
    .describe(
      'An ISO timestamp string indicating when the object was created. Do not set directly.'
    ),
  updatedAt: z
    .string()
    .datetime()
    .describe(
      'An ISO timestamp string indicating when the object was updated. Do not set directly.'
    )
})

// Object representation to be used as the shape of transport in the "API boundary".
// That means anything here must be "representable" as a regular ol' JSON.
export const UserSchemaZod = BaseSchema.extend({
  id: NonEmptyString.describe(
    'The user ID (that is auto-generated from the backend).'
  ),
  name: NonEmptyString.describe('The username that is provided by the user.'),
  role: z
    .enum(['user', 'superuser'])
    .default('user')
    .describe(
      'The role for the user. Note that superuser status can only be set by another superuser/admin.'
    ),
  deactivated: z
    .boolean()
    .default(true)
    .describe(
      'Deleted users will be marked with the `deactivated` flag. Do not set directly.'
    )
}).describe('The shape of a User object')

export const UsersQueryZod = UserSchemaZod.omit({
  createdAt: true,
  updatedAt: true
}).partial()

// Object representation of the payload that is allowed (coming into the backend) when creating a user
export const CreateUserBodyZod = UserSchemaZod.pick({
  id: true,
  name: true
})

// Object representation of the payload that is allowed (coming into the backend) when updating a user
export const UpdateUserBodyZod = UserSchemaZod.pick({
  name: true,
  role: true,
  deactivated: true
}).partial()

// The .coerce is needed for querystring, as it's in form of key=value pairs
// and the resulting object is always going to be Map<string, string>.
// It is theoretically not needed for body, as it's JSON.parse'ing it.
// TODO: fix in OAS UI
export const DeleteUserQueryZod = z
  .object({
    hardDelete: CoercedBoolean
  })
  .partial()
  .optional()

const MetadataBaseSchema = StripObject.extend({
  author: z.string().describe('The author listed for the page.'),
  description: z.string().describe('The description listed for the page.'),
  lang: z.string().describe('The language listed for the page.'),
  publisher: z.string().describe('The publisher listed for the page.')
})

const MetadataDateSchema = z.coerce
  .date()
  .transform(
    val => `${val.getUTCFullYear()}-${val.getUTCMonth()}-${val.getUTCDate()}`
  )
  .describe('The date the page was published (in UTC).')
const MetadataLogoSchema = UrlSchema.describe(
  'The URL of the logo for the page.'
)

// TODO: check optional
const MetadataSchema = z
  .union([
    MetadataBaseSchema,
    MetadataBaseSchema.strict().extend({ date: MetadataDateSchema }),
    MetadataBaseSchema.strict().extend({ logo: MetadataLogoSchema }),
    MetadataBaseSchema.strict().extend({
      date: MetadataDateSchema,
      logo: MetadataLogoSchema
    })
  ])
  .optional()
  .describe(
    'A set of metadata about the link that was shortened. See the metascraper project for more info.'
  )

// Object representation to be used as the shape of transport in the "API boundary".
// That means anything here must be "representable" as a regular ol' JSON,
// and that the shape of the object represents the *external* shape of the Link, not internal.
export const LinkSchemaZod = BaseSchema.extend({
  id: z.string().describe('The ID of the link. Generated by the backend.'),
  creatorId: UserSchemaZod.shape.id.describe(
    'ID of the user who created the link.'
  ),
  // TODO: separate schemas for transformation & validation
  originalLink: UrlSchema.describe('The link that was shortened.'),
  shortLink: UrlSchema.describe(
    'The shortened link with auto-generated URL pathname.'
  ),
  brandLink: UrlSchema.optional().describe(
    'The shortened link with a user-specified URL pathname.'
  ),
  metadata: MetadataSchema
})

export const LinksQueryZod = LinkSchemaZod.omit({
  createdAt: true,
  updatedAt: true
}).partial()

export const CreateLinkBodyZod = LinkSchemaZod.pick({
  originalLink: true
}).extend({
  pathname: z
    .string()
    .min(4)
    .max(25)
    .regex(/^[\w-]+$/) // a-z, A-Z, 0-9, -
    .refine(
      // Can't be done with JSON Schema (3)
      val => {
        // Since custom and auto-generated hash are both mounted under /,
        // we need to check that custom hash CAN'T clash with autogenerated hash.
        try {
          const ids = hashids.decode(val)
          return ids.length ? false : true
        } catch (err) {
          // when the hash contains "invalid" characters, we know for sure it CAN'T clash.
          return true
        }
      },
      {
        message: 'You cannot pick this pathname.'
      }
    )
    .optional()
    .describe(
      'You can set a pathname to customize the shortened link (see: brandLink).'
    )
})

// The check of "don't allow update if the path is already set" belongs to authorization
export const UpdateLinkBodyZod = CreateLinkBodyZod.pick({
  pathname: true
}).merge(LinkSchemaZod.pick({ metadata: true }))
