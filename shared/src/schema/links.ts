import * as z from 'zod'

import { hashids } from '../index.js'
import { StripObject, NormalizedURL, BaseModel } from './base.js'
import { UserSchemaZod } from './users.js'

const MetadataBaseSchema = StripObject.extend({
  author: z.string().describe('The author listed for the page.'),
  description: z.string().describe('The description listed for the page.'),
  lang: z.string().describe('The language listed for the page.'),
  publisher: z.string().describe('The publisher listed for the page.')
})

const MetadataDateSchema = z.coerce
  .date()
  .transform(
    val => `${val.getUTCFullYear()}-${val.getUTCMonth()}-${val.getUTCDate()}`
  )
  .describe('The date the page was published (in UTC).')
const MetadataLogoSchema = NormalizedURL.describe(
  'The URL of the logo for the page.'
)

// TODO: check optional
const MetadataSchema = z
  .union([
    MetadataBaseSchema,
    MetadataBaseSchema.strict().extend({ date: MetadataDateSchema }),
    MetadataBaseSchema.strict().extend({ logo: MetadataLogoSchema }),
    MetadataBaseSchema.strict().extend({
      date: MetadataDateSchema,
      logo: MetadataLogoSchema
    })
  ])
  .optional()
  .describe(
    'A set of metadata about the link that was shortened. See the metascraper project for more info.'
  )

// Object representation to be used as the shape of transport in the "API boundary".
// That means anything here must be "representable" as a regular ol' JSON,
// and that the shape of the object represents the *external* shape of the Link, not internal.
export const LinkSchemaZod = BaseModel.extend({
  id: z.string().describe('The ID of the link. Generated by the backend.'),
  creatorId: UserSchemaZod.shape.id.describe(
    'ID of the user who created the link.'
  ),
  // TODO: separate schemas for transformation & validation
  originalLink: NormalizedURL.describe('The link that was shortened.'),
  shortLink: NormalizedURL.describe(
    'The shortened link with auto-generated URL pathname.'
  ),
  brandLink: NormalizedURL.optional().describe(
    'The shortened link with a user-specified URL pathname.'
  ),
  metadata: MetadataSchema
})

export const LinksQueryZod = LinkSchemaZod.omit({
  createdAt: true,
  updatedAt: true
}).partial()

export const CreateLinkBodyZod = LinkSchemaZod.pick({
  originalLink: true
}).extend({
  pathname: z
    .string()
    .min(4)
    .max(25)
    .regex(/^[\w-]+$/) // a-z, A-Z, 0-9, -
    .refine(
      // Can't be done with JSON Schema (3)
      val => {
        // Since custom and auto-generated hash are both mounted under /,
        // we need to check that custom hash CAN'T clash with autogenerated hash.
        try {
          const ids = hashids.decode(val)
          return ids.length ? false : true
        } catch (err) {
          // when the hash contains "invalid" characters, we know for sure it CAN'T clash.
          return true
        }
      },
      {
        message: 'You cannot pick this pathname.'
      }
    )
    .optional()
    .describe(
      'You can set a pathname to customize the shortened link (see: brandLink).'
    )
})

// The check of "don't allow update if the path is already set" belongs to authorization
export const UpdateLinkBodyZod = CreateLinkBodyZod.pick({
  pathname: true
}).merge(LinkSchemaZod.pick({ metadata: true }))
